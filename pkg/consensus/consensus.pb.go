// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: consensus.proto

package proto

import (
	"fmt"
	"io"
	"math"

	proto "github.com/golang/protobuf/proto"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// All information about a block that is relevant to consensus
type ConsensusBlock struct {
	BlockId    []byte `protobuf:"bytes,1,opt,name=block_id,json=blockId,proto3" json:"block_id,omitempty"`
	PreviousId []byte `protobuf:"bytes,2,opt,name=previous_id,json=previousId,proto3" json:"previous_id,omitempty"`
	// The id of peer that signed this block
	SignerId []byte `protobuf:"bytes,3,opt,name=signer_id,json=signerId,proto3" json:"signer_id,omitempty"`
	BlockNum uint64 `protobuf:"varint,4,opt,name=block_num,json=blockNum,proto3" json:"block_num,omitempty"`
	Payload  []byte `protobuf:"bytes,5,opt,name=payload,proto3" json:"payload,omitempty"`
	// A summary of the contents of the block
	Summary              []byte   `protobuf:"bytes,6,opt,name=summary,proto3" json:"summary,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConsensusBlock) Reset()         { *m = ConsensusBlock{} }
func (m *ConsensusBlock) String() string { return proto.CompactTextString(m) }
func (*ConsensusBlock) ProtoMessage()    {}
func (*ConsensusBlock) Descriptor() ([]byte, []int) {
	return fileDescriptor_consensus_6dbf80fb586bfae0, []int{0}
}
func (m *ConsensusBlock) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsensusBlock) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConsensusBlock.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ConsensusBlock) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsensusBlock.Merge(dst, src)
}
func (m *ConsensusBlock) XXX_Size() int {
	return m.Size()
}
func (m *ConsensusBlock) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsensusBlock.DiscardUnknown(m)
}

var xxx_messageInfo_ConsensusBlock proto.InternalMessageInfo

func (m *ConsensusBlock) GetBlockId() []byte {
	if m != nil {
		return m.BlockId
	}
	return nil
}

func (m *ConsensusBlock) GetPreviousId() []byte {
	if m != nil {
		return m.PreviousId
	}
	return nil
}

func (m *ConsensusBlock) GetSignerId() []byte {
	if m != nil {
		return m.SignerId
	}
	return nil
}

func (m *ConsensusBlock) GetBlockNum() uint64 {
	if m != nil {
		return m.BlockNum
	}
	return 0
}

func (m *ConsensusBlock) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *ConsensusBlock) GetSummary() []byte {
	if m != nil {
		return m.Summary
	}
	return nil
}

// Information about a peer that is relevant to consensus
type ConsensusPeerInfo struct {
	// The unique id for this peer. This can be correlated with the signer id
	// on consensus blocks.
	PeerId               []byte   `protobuf:"bytes,1,opt,name=peer_id,json=peerId,proto3" json:"peer_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConsensusPeerInfo) Reset()         { *m = ConsensusPeerInfo{} }
func (m *ConsensusPeerInfo) String() string { return proto.CompactTextString(m) }
func (*ConsensusPeerInfo) ProtoMessage()    {}
func (*ConsensusPeerInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_consensus_6dbf80fb586bfae0, []int{1}
}
func (m *ConsensusPeerInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsensusPeerInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConsensusPeerInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ConsensusPeerInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsensusPeerInfo.Merge(dst, src)
}
func (m *ConsensusPeerInfo) XXX_Size() int {
	return m.Size()
}
func (m *ConsensusPeerInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsensusPeerInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ConsensusPeerInfo proto.InternalMessageInfo

func (m *ConsensusPeerInfo) GetPeerId() []byte {
	if m != nil {
		return m.PeerId
	}
	return nil
}

// A new block was received and passed initial consensus validation
type ConsensusNotifyBlockNew struct {
	Block                *ConsensusBlock `protobuf:"bytes,1,opt,name=block" json:"block,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *ConsensusNotifyBlockNew) Reset()         { *m = ConsensusNotifyBlockNew{} }
func (m *ConsensusNotifyBlockNew) String() string { return proto.CompactTextString(m) }
func (*ConsensusNotifyBlockNew) ProtoMessage()    {}
func (*ConsensusNotifyBlockNew) Descriptor() ([]byte, []int) {
	return fileDescriptor_consensus_6dbf80fb586bfae0, []int{2}
}
func (m *ConsensusNotifyBlockNew) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsensusNotifyBlockNew) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConsensusNotifyBlockNew.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ConsensusNotifyBlockNew) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsensusNotifyBlockNew.Merge(dst, src)
}
func (m *ConsensusNotifyBlockNew) XXX_Size() int {
	return m.Size()
}
func (m *ConsensusNotifyBlockNew) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsensusNotifyBlockNew.DiscardUnknown(m)
}

var xxx_messageInfo_ConsensusNotifyBlockNew proto.InternalMessageInfo

func (m *ConsensusNotifyBlockNew) GetBlock() *ConsensusBlock {
	if m != nil {
		return m.Block
	}
	return nil
}

// This block can be committed successfully
type ConsensusNotifyBlockValid struct {
	BlockId              []byte   `protobuf:"bytes,1,opt,name=block_id,json=blockId,proto3" json:"block_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConsensusNotifyBlockValid) Reset()         { *m = ConsensusNotifyBlockValid{} }
func (m *ConsensusNotifyBlockValid) String() string { return proto.CompactTextString(m) }
func (*ConsensusNotifyBlockValid) ProtoMessage()    {}
func (*ConsensusNotifyBlockValid) Descriptor() ([]byte, []int) {
	return fileDescriptor_consensus_6dbf80fb586bfae0, []int{3}
}
func (m *ConsensusNotifyBlockValid) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsensusNotifyBlockValid) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConsensusNotifyBlockValid.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ConsensusNotifyBlockValid) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsensusNotifyBlockValid.Merge(dst, src)
}
func (m *ConsensusNotifyBlockValid) XXX_Size() int {
	return m.Size()
}
func (m *ConsensusNotifyBlockValid) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsensusNotifyBlockValid.DiscardUnknown(m)
}

var xxx_messageInfo_ConsensusNotifyBlockValid proto.InternalMessageInfo

func (m *ConsensusNotifyBlockValid) GetBlockId() []byte {
	if m != nil {
		return m.BlockId
	}
	return nil
}

// This block cannot be committed successfully
type ConsensusNotifyBlockInvalid struct {
	BlockId              []byte   `protobuf:"bytes,1,opt,name=block_id,json=blockId,proto3" json:"block_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConsensusNotifyBlockInvalid) Reset()         { *m = ConsensusNotifyBlockInvalid{} }
func (m *ConsensusNotifyBlockInvalid) String() string { return proto.CompactTextString(m) }
func (*ConsensusNotifyBlockInvalid) ProtoMessage()    {}
func (*ConsensusNotifyBlockInvalid) Descriptor() ([]byte, []int) {
	return fileDescriptor_consensus_6dbf80fb586bfae0, []int{4}
}
func (m *ConsensusNotifyBlockInvalid) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsensusNotifyBlockInvalid) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConsensusNotifyBlockInvalid.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ConsensusNotifyBlockInvalid) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsensusNotifyBlockInvalid.Merge(dst, src)
}
func (m *ConsensusNotifyBlockInvalid) XXX_Size() int {
	return m.Size()
}
func (m *ConsensusNotifyBlockInvalid) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsensusNotifyBlockInvalid.DiscardUnknown(m)
}

var xxx_messageInfo_ConsensusNotifyBlockInvalid proto.InternalMessageInfo

func (m *ConsensusNotifyBlockInvalid) GetBlockId() []byte {
	if m != nil {
		return m.BlockId
	}
	return nil
}

// This block has been committed
type ConsensusNotifyBlockCommit struct {
	BlockId              []byte   `protobuf:"bytes,1,opt,name=block_id,json=blockId,proto3" json:"block_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConsensusNotifyBlockCommit) Reset()         { *m = ConsensusNotifyBlockCommit{} }
func (m *ConsensusNotifyBlockCommit) String() string { return proto.CompactTextString(m) }
func (*ConsensusNotifyBlockCommit) ProtoMessage()    {}
func (*ConsensusNotifyBlockCommit) Descriptor() ([]byte, []int) {
	return fileDescriptor_consensus_6dbf80fb586bfae0, []int{5}
}
func (m *ConsensusNotifyBlockCommit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsensusNotifyBlockCommit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConsensusNotifyBlockCommit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ConsensusNotifyBlockCommit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsensusNotifyBlockCommit.Merge(dst, src)
}
func (m *ConsensusNotifyBlockCommit) XXX_Size() int {
	return m.Size()
}
func (m *ConsensusNotifyBlockCommit) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsensusNotifyBlockCommit.DiscardUnknown(m)
}

var xxx_messageInfo_ConsensusNotifyBlockCommit proto.InternalMessageInfo

func (m *ConsensusNotifyBlockCommit) GetBlockId() []byte {
	if m != nil {
		return m.BlockId
	}
	return nil
}

// The engine has been activated
type ConsensusNotifyEngineActivated struct {
	// Startup Info
	ChainHead            *ConsensusBlock      `protobuf:"bytes,1,opt,name=chain_head,json=chainHead" json:"chain_head,omitempty"`
	Peers                []*ConsensusPeerInfo `protobuf:"bytes,2,rep,name=peers" json:"peers,omitempty"`
	LocalPeerInfo        *ConsensusPeerInfo   `protobuf:"bytes,3,opt,name=local_peer_info,json=localPeerInfo" json:"local_peer_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *ConsensusNotifyEngineActivated) Reset()         { *m = ConsensusNotifyEngineActivated{} }
func (m *ConsensusNotifyEngineActivated) String() string { return proto.CompactTextString(m) }
func (*ConsensusNotifyEngineActivated) ProtoMessage()    {}
func (*ConsensusNotifyEngineActivated) Descriptor() ([]byte, []int) {
	return fileDescriptor_consensus_6dbf80fb586bfae0, []int{6}
}
func (m *ConsensusNotifyEngineActivated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsensusNotifyEngineActivated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConsensusNotifyEngineActivated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ConsensusNotifyEngineActivated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsensusNotifyEngineActivated.Merge(dst, src)
}
func (m *ConsensusNotifyEngineActivated) XXX_Size() int {
	return m.Size()
}
func (m *ConsensusNotifyEngineActivated) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsensusNotifyEngineActivated.DiscardUnknown(m)
}

var xxx_messageInfo_ConsensusNotifyEngineActivated proto.InternalMessageInfo

func (m *ConsensusNotifyEngineActivated) GetChainHead() *ConsensusBlock {
	if m != nil {
		return m.ChainHead
	}
	return nil
}

func (m *ConsensusNotifyEngineActivated) GetPeers() []*ConsensusPeerInfo {
	if m != nil {
		return m.Peers
	}
	return nil
}

func (m *ConsensusNotifyEngineActivated) GetLocalPeerInfo() *ConsensusPeerInfo {
	if m != nil {
		return m.LocalPeerInfo
	}
	return nil
}

// The engine has been deactivated
type ConsensusNotifyEngineDeactivated struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConsensusNotifyEngineDeactivated) Reset()         { *m = ConsensusNotifyEngineDeactivated{} }
func (m *ConsensusNotifyEngineDeactivated) String() string { return proto.CompactTextString(m) }
func (*ConsensusNotifyEngineDeactivated) ProtoMessage()    {}
func (*ConsensusNotifyEngineDeactivated) Descriptor() ([]byte, []int) {
	return fileDescriptor_consensus_6dbf80fb586bfae0, []int{7}
}
func (m *ConsensusNotifyEngineDeactivated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsensusNotifyEngineDeactivated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConsensusNotifyEngineDeactivated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ConsensusNotifyEngineDeactivated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsensusNotifyEngineDeactivated.Merge(dst, src)
}
func (m *ConsensusNotifyEngineDeactivated) XXX_Size() int {
	return m.Size()
}
func (m *ConsensusNotifyEngineDeactivated) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsensusNotifyEngineDeactivated.DiscardUnknown(m)
}

var xxx_messageInfo_ConsensusNotifyEngineDeactivated proto.InternalMessageInfo

// Confirm that the notification was received. The validator message
// correlation id is used to determine which notification this is an ack for.
type ConsensusNotifyAck struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConsensusNotifyAck) Reset()         { *m = ConsensusNotifyAck{} }
func (m *ConsensusNotifyAck) String() string { return proto.CompactTextString(m) }
func (*ConsensusNotifyAck) ProtoMessage()    {}
func (*ConsensusNotifyAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_consensus_6dbf80fb586bfae0, []int{8}
}
func (m *ConsensusNotifyAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsensusNotifyAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConsensusNotifyAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ConsensusNotifyAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsensusNotifyAck.Merge(dst, src)
}
func (m *ConsensusNotifyAck) XXX_Size() int {
	return m.Size()
}
func (m *ConsensusNotifyAck) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsensusNotifyAck.DiscardUnknown(m)
}

var xxx_messageInfo_ConsensusNotifyAck proto.InternalMessageInfo

func init() {
	proto.RegisterType((*ConsensusBlock)(nil), "proto.ConsensusBlock")
	proto.RegisterType((*ConsensusPeerInfo)(nil), "proto.ConsensusPeerInfo")
	proto.RegisterType((*ConsensusNotifyBlockNew)(nil), "proto.ConsensusNotifyBlockNew")
	proto.RegisterType((*ConsensusNotifyBlockValid)(nil), "proto.ConsensusNotifyBlockValid")
	proto.RegisterType((*ConsensusNotifyBlockInvalid)(nil), "proto.ConsensusNotifyBlockInvalid")
	proto.RegisterType((*ConsensusNotifyBlockCommit)(nil), "proto.ConsensusNotifyBlockCommit")
	proto.RegisterType((*ConsensusNotifyEngineActivated)(nil), "proto.ConsensusNotifyEngineActivated")
	proto.RegisterType((*ConsensusNotifyEngineDeactivated)(nil), "proto.ConsensusNotifyEngineDeactivated")
	proto.RegisterType((*ConsensusNotifyAck)(nil), "proto.ConsensusNotifyAck")
}
func (m *ConsensusBlock) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsensusBlock) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.BlockId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintConsensus(dAtA, i, uint64(len(m.BlockId)))
		i += copy(dAtA[i:], m.BlockId)
	}
	if len(m.PreviousId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConsensus(dAtA, i, uint64(len(m.PreviousId)))
		i += copy(dAtA[i:], m.PreviousId)
	}
	if len(m.SignerId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintConsensus(dAtA, i, uint64(len(m.SignerId)))
		i += copy(dAtA[i:], m.SignerId)
	}
	if m.BlockNum != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintConsensus(dAtA, i, uint64(m.BlockNum))
	}
	if len(m.Payload) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintConsensus(dAtA, i, uint64(len(m.Payload)))
		i += copy(dAtA[i:], m.Payload)
	}
	if len(m.Summary) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintConsensus(dAtA, i, uint64(len(m.Summary)))
		i += copy(dAtA[i:], m.Summary)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConsensusPeerInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsensusPeerInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PeerId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintConsensus(dAtA, i, uint64(len(m.PeerId)))
		i += copy(dAtA[i:], m.PeerId)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConsensusNotifyBlockNew) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsensusNotifyBlockNew) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Block != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintConsensus(dAtA, i, uint64(m.Block.Size()))
		n1, err := m.Block.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConsensusNotifyBlockValid) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsensusNotifyBlockValid) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.BlockId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintConsensus(dAtA, i, uint64(len(m.BlockId)))
		i += copy(dAtA[i:], m.BlockId)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConsensusNotifyBlockInvalid) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsensusNotifyBlockInvalid) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.BlockId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintConsensus(dAtA, i, uint64(len(m.BlockId)))
		i += copy(dAtA[i:], m.BlockId)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConsensusNotifyBlockCommit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsensusNotifyBlockCommit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.BlockId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintConsensus(dAtA, i, uint64(len(m.BlockId)))
		i += copy(dAtA[i:], m.BlockId)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConsensusNotifyEngineActivated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsensusNotifyEngineActivated) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChainHead != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintConsensus(dAtA, i, uint64(m.ChainHead.Size()))
		n2, err := m.ChainHead.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.Peers) > 0 {
		for _, msg := range m.Peers {
			dAtA[i] = 0x12
			i++
			i = encodeVarintConsensus(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.LocalPeerInfo != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintConsensus(dAtA, i, uint64(m.LocalPeerInfo.Size()))
		n3, err := m.LocalPeerInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConsensusNotifyEngineDeactivated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsensusNotifyEngineDeactivated) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConsensusNotifyAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsensusNotifyAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintConsensus(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ConsensusBlock) Size() (n int) {
	var l int
	_ = l
	l = len(m.BlockId)
	if l > 0 {
		n += 1 + l + sovConsensus(uint64(l))
	}
	l = len(m.PreviousId)
	if l > 0 {
		n += 1 + l + sovConsensus(uint64(l))
	}
	l = len(m.SignerId)
	if l > 0 {
		n += 1 + l + sovConsensus(uint64(l))
	}
	if m.BlockNum != 0 {
		n += 1 + sovConsensus(uint64(m.BlockNum))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovConsensus(uint64(l))
	}
	l = len(m.Summary)
	if l > 0 {
		n += 1 + l + sovConsensus(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConsensusPeerInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.PeerId)
	if l > 0 {
		n += 1 + l + sovConsensus(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConsensusNotifyBlockNew) Size() (n int) {
	var l int
	_ = l
	if m.Block != nil {
		l = m.Block.Size()
		n += 1 + l + sovConsensus(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConsensusNotifyBlockValid) Size() (n int) {
	var l int
	_ = l
	l = len(m.BlockId)
	if l > 0 {
		n += 1 + l + sovConsensus(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConsensusNotifyBlockInvalid) Size() (n int) {
	var l int
	_ = l
	l = len(m.BlockId)
	if l > 0 {
		n += 1 + l + sovConsensus(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConsensusNotifyBlockCommit) Size() (n int) {
	var l int
	_ = l
	l = len(m.BlockId)
	if l > 0 {
		n += 1 + l + sovConsensus(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConsensusNotifyEngineActivated) Size() (n int) {
	var l int
	_ = l
	if m.ChainHead != nil {
		l = m.ChainHead.Size()
		n += 1 + l + sovConsensus(uint64(l))
	}
	if len(m.Peers) > 0 {
		for _, e := range m.Peers {
			l = e.Size()
			n += 1 + l + sovConsensus(uint64(l))
		}
	}
	if m.LocalPeerInfo != nil {
		l = m.LocalPeerInfo.Size()
		n += 1 + l + sovConsensus(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConsensusNotifyEngineDeactivated) Size() (n int) {
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConsensusNotifyAck) Size() (n int) {
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovConsensus(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozConsensus(x uint64) (n int) {
	return sovConsensus(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ConsensusBlock) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsensusBlock: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsensusBlock: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockId = append(m.BlockId[:0], dAtA[iNdEx:postIndex]...)
			if m.BlockId == nil {
				m.BlockId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreviousId = append(m.PreviousId[:0], dAtA[iNdEx:postIndex]...)
			if m.PreviousId == nil {
				m.PreviousId = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignerId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignerId = append(m.SignerId[:0], dAtA[iNdEx:postIndex]...)
			if m.SignerId == nil {
				m.SignerId = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockNum", wireType)
			}
			m.BlockNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockNum |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Summary", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Summary = append(m.Summary[:0], dAtA[iNdEx:postIndex]...)
			if m.Summary == nil {
				m.Summary = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsensus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConsensus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsensusPeerInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsensusPeerInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsensusPeerInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerId = append(m.PeerId[:0], dAtA[iNdEx:postIndex]...)
			if m.PeerId == nil {
				m.PeerId = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsensus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConsensus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsensusNotifyBlockNew) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsensusNotifyBlockNew: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsensusNotifyBlockNew: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Block == nil {
				m.Block = &ConsensusBlock{}
			}
			if err := m.Block.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsensus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConsensus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsensusNotifyBlockValid) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsensusNotifyBlockValid: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsensusNotifyBlockValid: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockId = append(m.BlockId[:0], dAtA[iNdEx:postIndex]...)
			if m.BlockId == nil {
				m.BlockId = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsensus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConsensus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsensusNotifyBlockInvalid) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsensusNotifyBlockInvalid: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsensusNotifyBlockInvalid: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockId = append(m.BlockId[:0], dAtA[iNdEx:postIndex]...)
			if m.BlockId == nil {
				m.BlockId = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsensus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConsensus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsensusNotifyBlockCommit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsensusNotifyBlockCommit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsensusNotifyBlockCommit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockId = append(m.BlockId[:0], dAtA[iNdEx:postIndex]...)
			if m.BlockId == nil {
				m.BlockId = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsensus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConsensus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsensusNotifyEngineActivated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsensusNotifyEngineActivated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsensusNotifyEngineActivated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainHead", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChainHead == nil {
				m.ChainHead = &ConsensusBlock{}
			}
			if err := m.ChainHead.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Peers = append(m.Peers, &ConsensusPeerInfo{})
			if err := m.Peers[len(m.Peers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalPeerInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LocalPeerInfo == nil {
				m.LocalPeerInfo = &ConsensusPeerInfo{}
			}
			if err := m.LocalPeerInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsensus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConsensus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsensusNotifyEngineDeactivated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsensusNotifyEngineDeactivated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsensusNotifyEngineDeactivated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipConsensus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConsensus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsensusNotifyAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsensusNotifyAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsensusNotifyAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipConsensus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConsensus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipConsensus(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowConsensus
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthConsensus
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowConsensus
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipConsensus(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthConsensus = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowConsensus   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("consensus.proto", fileDescriptor_consensus_6dbf80fb586bfae0) }

var fileDescriptor_consensus_6dbf80fb586bfae0 = []byte{
	// 396 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x92, 0xdd, 0xce, 0xd2, 0x30,
	0x1c, 0xc6, 0xed, 0x0b, 0xe3, 0xe3, 0x8f, 0x8a, 0x36, 0x1a, 0x86, 0x24, 0x73, 0xe9, 0x11, 0x89,
	0x86, 0x03, 0x34, 0xea, 0xa1, 0x80, 0x1a, 0x77, 0x42, 0xcc, 0x0e, 0x3c, 0x25, 0x65, 0x2d, 0xd0,
	0xb0, 0xb5, 0xcb, 0x3e, 0x30, 0xdc, 0x89, 0xd7, 0xe2, 0x15, 0x70, 0xe8, 0x25, 0x18, 0xbc, 0x11,
	0xb3, 0x96, 0x91, 0x48, 0x96, 0xbd, 0x47, 0xf0, 0xf4, 0x79, 0x7e, 0xfd, 0x7f, 0x74, 0xd0, 0x0f,
	0x94, 0x4c, 0xb9, 0x4c, 0xf3, 0x74, 0x12, 0x27, 0x2a, 0x53, 0xd8, 0xd2, 0x3f, 0xe4, 0x17, 0x82,
	0xc7, 0x8b, 0xd2, 0x9a, 0x87, 0x2a, 0xd8, 0xe3, 0x21, 0x74, 0xd6, 0xc5, 0x9f, 0x95, 0x60, 0x36,
	0x72, 0xd1, 0xf8, 0xa1, 0xdf, 0xd6, 0xda, 0x63, 0xf8, 0x25, 0xf4, 0xe2, 0x84, 0x1f, 0x84, 0xca,
	0xd3, 0xc2, 0xbd, 0xd3, 0x2e, 0x94, 0x47, 0x1e, 0xc3, 0x23, 0xe8, 0xa6, 0x62, 0x2b, 0x79, 0x52,
	0xd8, 0x0d, 0x6d, 0x77, 0xcc, 0x81, 0x31, 0xcd, 0xc5, 0x32, 0x8f, 0xec, 0xa6, 0x8b, 0xc6, 0x4d,
	0xdf, 0x54, 0x5a, 0xe6, 0x11, 0xb6, 0xa1, 0x1d, 0xd3, 0x63, 0xa8, 0x28, 0xb3, 0x2d, 0x53, 0xf4,
	0x22, 0x0b, 0x27, 0xcd, 0xa3, 0x88, 0x26, 0x47, 0xbb, 0x65, 0x9c, 0x8b, 0x24, 0xaf, 0xe1, 0xe9,
	0xb5, 0xf7, 0x6f, 0x9c, 0x27, 0x9e, 0xdc, 0x28, 0x3c, 0x80, 0x76, 0xcc, 0x4d, 0x03, 0xa6, 0xfb,
	0x56, 0x21, 0x3d, 0x46, 0xbe, 0xc0, 0xe0, 0x9a, 0x5e, 0xaa, 0x4c, 0x6c, 0x8e, 0x7a, 0xde, 0x25,
	0xff, 0x81, 0x5f, 0x81, 0xa5, 0x1b, 0xd1, 0x44, 0x6f, 0xfa, 0xdc, 0xec, 0x68, 0xf2, 0xff, 0x62,
	0x7c, 0x93, 0x21, 0xef, 0x60, 0x58, 0x75, 0xcf, 0x77, 0x1a, 0x0a, 0x56, 0xb3, 0x3c, 0xf2, 0x01,
	0x46, 0x55, 0x9c, 0x27, 0x0f, 0xf7, 0x91, 0xef, 0xe1, 0x45, 0x15, 0xb9, 0x50, 0x51, 0x24, 0xb2,
	0x3a, 0xf0, 0x84, 0xc0, 0xb9, 0x21, 0x3f, 0xcb, 0xad, 0x90, 0x7c, 0x16, 0x64, 0xe2, 0x40, 0x33,
	0xce, 0xf0, 0x5b, 0x80, 0x60, 0x47, 0x85, 0x5c, 0xed, 0x38, 0x65, 0xf5, 0xf3, 0x77, 0x75, 0xf0,
	0x2b, 0xa7, 0x0c, 0x4f, 0xc0, 0x2a, 0xb6, 0x9a, 0xda, 0x77, 0x6e, 0x63, 0xdc, 0x9b, 0xda, 0xb7,
	0x40, 0xf9, 0x1a, 0xbe, 0x89, 0xe1, 0x8f, 0xd0, 0x0f, 0x55, 0x40, 0xc3, 0x95, 0x79, 0x1a, 0xb9,
	0x51, 0xfa, 0xeb, 0xa8, 0x23, 0x1f, 0x69, 0xa0, 0x94, 0x84, 0x80, 0x5b, 0x39, 0xc9, 0x27, 0x4e,
	0xcb, 0x59, 0xc8, 0x33, 0xc0, 0x37, 0x99, 0x59, 0xb0, 0x9f, 0x3f, 0x39, 0x9d, 0x1d, 0xf4, 0xfb,
	0xec, 0xa0, 0x3f, 0x67, 0x07, 0xfd, 0xfc, 0xeb, 0x3c, 0x58, 0xb7, 0x74, 0xcd, 0x37, 0xff, 0x02,
	0x00, 0x00, 0xff, 0xff, 0x91, 0x15, 0x12, 0x62, 0x15, 0x03, 0x00, 0x00,
}
